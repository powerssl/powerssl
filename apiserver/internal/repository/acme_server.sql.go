// Code generated by sqlc. DO NOT EDIT.
// source: acme_server.sql

package repository

import (
	"context"

	"github.com/google/uuid"
)

const CreateACMEServer = `-- name: CreateACMEServer :one
INSERT INTO acme_servers (display_name, directory_url, integration_name)
VALUES ($1, $2, $3)
RETURNING id, display_name, directory_url, integration_name, created_at, updated_at, deleted_at
`

type CreateACMEServerParams struct {
	DisplayName     string `db:"display_name" json:"displayName"`
	DirectoryUrl    string `db:"directory_url" json:"directoryUrl"`
	IntegrationName string `db:"integration_name" json:"integrationName"`
}

func (q *Queries) CreateACMEServer(ctx context.Context, arg CreateACMEServerParams) (AcmeServer, error) {
	row := q.db.QueryRow(ctx, CreateACMEServer, arg.DisplayName, arg.DirectoryUrl, arg.IntegrationName)
	var i AcmeServer
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.DirectoryUrl,
		&i.IntegrationName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const DeleteACMEServer = `-- name: DeleteACMEServer :exec
UPDATE acme_servers
SET deleted_at = NOW()
WHERE deleted_at IS NULL
  AND id = $1
`

func (q *Queries) DeleteACMEServer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteACMEServer, id)
	return err
}

const GetACMEServer = `-- name: GetACMEServer :one
SELECT id, display_name, directory_url, integration_name, created_at, updated_at, deleted_at
FROM acme_servers
WHERE deleted_at IS NULL
  AND id = $1
LIMIT 1
`

func (q *Queries) GetACMEServer(ctx context.Context, id uuid.UUID) (AcmeServer, error) {
	row := q.db.QueryRow(ctx, GetACMEServer, id)
	var i AcmeServer
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.DirectoryUrl,
		&i.IntegrationName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const ListACMEServers = `-- name: ListACMEServers :many
SELECT id, display_name, directory_url, integration_name, created_at, updated_at, deleted_at
FROM acme_servers
WHERE deleted_at IS NULL
ORDER BY CASE
             WHEN $1::text = 'created_at' THEN created_at
             WHEN $1::text = 'updated_at' THEN updated_at
             END
LIMIT $3 OFFSET $2
`

type ListACMEServersParams struct {
	SqlOrder  string `db:"sql_order" json:"sqlOrder"`
	SqlOffset int32  `db:"sql_offset" json:"sqlOffset"`
	SqlLimit  int32  `db:"sql_limit" json:"sqlLimit"`
}

func (q *Queries) ListACMEServers(ctx context.Context, arg ListACMEServersParams) ([]AcmeServer, error) {
	rows, err := q.db.Query(ctx, ListACMEServers, arg.SqlOrder, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AcmeServer
	for rows.Next() {
		var i AcmeServer
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.DirectoryUrl,
			&i.IntegrationName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateACMEServer = `-- name: UpdateACMEServer :one
UPDATE acme_servers
SET display_name     = CASE
                           WHEN $1::bool THEN $2::text
                           ELSE display_name
    END,
    directory_url    = CASE
                           WHEN $3::bool THEN $4::text
                           ELSE directory_url
        END,
    integration_name = CASE
                           WHEN $5::bool THEN $6::text
                           ELSE integration_name
        END,
    updated_at       = NOW()
WHERE deleted_at IS NULL
  AND id = $7
RETURNING id, display_name, directory_url, integration_name, created_at, updated_at, deleted_at
`

type UpdateACMEServerParams struct {
	SetDisplayName     bool      `db:"set_display_name" json:"setDisplayName"`
	DisplayName        string    `db:"display_name" json:"displayName"`
	SetDirectoryUrl    bool      `db:"set_directory_url" json:"setDirectoryUrl"`
	DirectoryUrl       string    `db:"directory_url" json:"directoryUrl"`
	SetIntegrationName bool      `db:"set_integration_name" json:"setIntegrationName"`
	IntegrationName    string    `db:"integration_name" json:"integrationName"`
	ID                 uuid.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateACMEServer(ctx context.Context, arg UpdateACMEServerParams) (AcmeServer, error) {
	row := q.db.QueryRow(ctx, UpdateACMEServer,
		arg.SetDisplayName,
		arg.DisplayName,
		arg.SetDirectoryUrl,
		arg.DirectoryUrl,
		arg.SetIntegrationName,
		arg.IntegrationName,
		arg.ID,
	)
	var i AcmeServer
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.DirectoryUrl,
		&i.IntegrationName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
